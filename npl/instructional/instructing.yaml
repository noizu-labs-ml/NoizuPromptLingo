```yaml
name: instructing
brief: Instruction patterns and control structures for agent behavior
description: |
  Comprehensive documentation for instructing patterns in NPL, providing syntax for 
  templates, algorithms, symbolic logic, and formal proofs to direct complex agent 
  reasoning and response construction.
purpose: |
  To enable precise direction of complex reasoning processes, iterative refinement, 
  and systematic problem-solving through structured commands and logical constructs.

components:
  - name: handlebars-instructions
    syntax:
      - name: conditional-block
        syntax: |
          {{if <condition>}}
            [content if true]
          {{else}}
            [content if false]
          {{/if}}
      - name: iteration-block
        syntax: |
          {{foreach <collection> as <item>}}
            [content for each item]
          {{/foreach}}
      - name: unless-block
        syntax: |
          {{unless <condition>}}
            [content if condition is false]
          {{/unless}}
    brief: Template-like control structures for dynamic content
    description: |
      Handlebars-like syntax used to instruct agents on how to process requests and format output. 
      It provides a familiar templating grammar for conditional rendering, iteration over collections, 
      and dynamic content inclusion based on context.
    purpose: |
      Generate repetitive content with variations, apply conditional logic to output sections, 
      or iterate over datasets without writing imperative code.
    labels:
      - block
      - logic
      - template
    examples:
      - name: conditional-logic
        brief: Conditional rendering based on user role
        priority: 0
        example: |
          {{if user.role == 'administrator'}}
            Show admin panel
          {{else}}
            Show user dashboard
          {{/if}}
      - name: iteration-loop
        brief: Iterating over a list of executives
        priority: 0
        example: |
          {{foreach business.executives as executive}}
          - Name: {{executive.name}}
          - Role: {{executive.role}}
          {{/foreach}}

  - name: algorithm-specification
    syntax:
      - name: generic-algorithm
        syntax: |
          ```alg
          [algorithm specification]
          ```
      - name: pseudocode-algorithm
        syntax: |
          ```alg-pseudo
          [pseudocode implementation]
          ```
      - name: language-specific-algorithm
        syntax: |
          ```alg-<language>
          [language-specific implementation]
          ```
      - name: flowchart-representation
        syntax: |
          ```alg-flowchart
          mermaid
          [flowchart definition]
          ```
    brief: Structured language for defining computational logic
    description: |
      Algorithm Specification Language (Alg-Speak) provides formal notation for expressing 
      computational logic, step-by-step procedures, and algorithmic thinking patterns. 
      It supports generic pseudocode, language-specific implementations, and flowchart visualizations.
    purpose: |
      Define precise computational procedures, document complex logic flows, or specify 
      algorithm implementations when exact processing steps are critical.
    labels:
      - block
      - definition
      - algorithm
    examples:
      - name: find-max-algorithm
        brief: Finding the maximum value in an array
        priority: 1
        example: |
          ```alg
          Algorithm: FindMaximum(array A)
          1. max ← A[0]
          2. for i = 1 to length(A) - 1 do
          3.   if A[i] > max then
          4.     max ← A[i]
          5.   end if
          6. end for
          7. return max
          ```
      - name: binary-search-pseudo
        brief: Binary search implementation in pseudocode
        priority: 1
        example: |
          ```alg-pseudo
          PROCEDURE BinarySearch(array, target):
            left = 0
            right = array.length - 1
            WHILE left <= right:
              mid = (left + right) / 2
              IF array[mid] = target:
                RETURN mid
              ELSE IF array[mid] < target:
                left = mid + 1
              ELSE:
                right = mid - 1
              END IF
            END WHILE
            RETURN -1
          ```

  - name: iterative-annotation
    syntax:
      - name: basic-refinement
        syntax: |
          ```annotation
          original: [existing content]
          issues: [identified problems]
          refinement: [improved version]
          ```
      - name: cyclic-refinement
        syntax: |
          ```annotation-cycle
          iteration: <number>
          focus: <area of improvement>
          changes: [specific modifications]
          validation: [verification method]
          ```
    brief: Progressive refinement patterns for code and design
    description: |
      Annotation patterns enable systematic improvement of outputs through iterative cycles. 
      They provide a structured format for documenting original content, identifying issues, 
      and tracking refinement versions.
    purpose: |
      Conduct code review and improvement cycles, UX design iteration processes, or 
      progressive solution refinement where feedback loops are required.
    labels:
      - block
      - guidance
      - refinement
    examples:
      - name: code-refinement
        brief: Improving a calculation function
        priority: 1
        example: |
          ```annotation
          original: |
            function calculate(a, b) {
              return a + b;
            }
          issues:
            - No input validation
            - Limited to addition only
          refinement: |
            function calculate(a, b, operation = 'add') {
              if (typeof a !== 'number' || typeof b !== 'number') {
                throw new Error('Invalid input: numbers required');
              }
              // ... switch case logic
            }
          ```

  - name: symbolic-logic
    syntax:
      - name: quantifiers
        syntax: |
          ∀   : Universal quantifier ("for all")
          ∃   : Existential quantifier ("there exists")
      - name: logical-connectives
        syntax: |
          ∧   : Logical AND
          ∨   : Logical OR
          ¬   : Logical NOT
          →   : Implication
      - name: set-operations
        syntax: |
          ∪   : Union
          ∩   : Intersection
          ⊆   : Subset
    brief: Formal notation for mathematical and logical relationships
    description: |
      Symbolic logic provides precise, unambiguous notation for expressing logical relationships, 
      mathematical operations, and reasoning structures using standardized symbols.
    purpose: |
      Provide formal specification of logical relationships, construct mathematical proofs, 
      or express conditional logic with mathematical rigor.
    labels:
      - inline
      - mathematical
      - logic
    examples:
      - name: set-operations
        brief: Defining a customer segment
        priority: 1
        example: |
          Customer segmentation:
          (sports_enthusiasts ∩ health_focused)
          ≡ {x : SportsInterest(x) ∧ HealthFocus(x)}
      - name: propositional-logic
        brief: Standard inference rules
        priority: 1
        example: |
          Modus Ponens: (P → Q) ∧ P ⊢ Q
          Modus Tollens: (P → Q) ∧ ¬Q ⊢ ¬P

  - name: formal-proof
    syntax:
      - name: proof-structure
        syntax: |
          ```proof
          Given: [premises]
          To Prove: [conclusion]
          Proof:
            1. [step] - [justification]
            ...
            n. [conclusion] - [final justification]
          ```
    brief: Structured frameworks for rigorous logical verification
    description: |
      Formal proof structures provide systematic frameworks for constructing valid logical 
      arguments and establishing the truth of statements through step-by-step reasoning and 
      inference rules.
    purpose: |
      Verify mathematical theorems, prove algorithm correctness, or verify system properties 
      where logical soundness must be demonstrated.
    labels:
      - block
      - verification
      - formal
    examples:
      - name: direct-proof
        brief: Proving if n is even then n² is even
        priority: 2
        example: |
          ```proof
          Theorem: If n is even, then n² is even.
          Given: n is even (n = 2k for some integer k)
          To Prove: n² is even

          Proof:
          1. n = 2k - Given (n is even)
          2. n² = (2k)² - Substitution
          3. n² = 4k² - Algebraic manipulation
          4. n² = 2(2k²) - Factoring
          5. Therefore, n² is even - Definition of even number ∎
          ```

  - name: higher-order-logic
    syntax:
      - name: predicate-quantification
        syntax: "∀P(P(x) → Q(x))"
      - name: function-abstraction
        syntax: "λx.φ(x)"
    brief: Advanced reasoning structures operating on logic itself
    description: |
      Higher-order logic patterns enable meta-level analysis, allowing reasoning about reasoning 
      processes themselves and manipulation of logical structures as objects.
    purpose: |
      Perform meta-reasoning about problem-solving approaches, create reusable logical frameworks, 
      or analyze patterns in reasoning processes.
    labels:
      - inline
      - meta
      - reasoning
    examples:
      - name: meta-logical-reasoning
        brief: Defining system properties
        priority: 2
        example: |
          ```logic
          Given logical system S:
          - Consistency(S) ≔ ¬∃φ(Provable(S,φ) ∧ Provable(S,¬φ))
          - Soundness(S) ≔ ∀φ(Provable(S,φ) → True(φ))
          ```

instructional:
  - name: instructing-purpose
    type: conceptual-explanation
    brief: Why instructing patterns exist
    content: |
      Instructing patterns provide specialized syntax for controlling agent behavior through structured commands, templates, and logical constructs. These patterns enable precise direction of complex reasoning processes, iterative refinement, and systematic problem-solving approaches.
    labels:
      - conceptual
      - overview

  - name: when-to-use-instructing
    type: usage-guideline
    brief: Scenarios best suited for instructing patterns
    content: |
      Use instructing patterns when you encounter the following scenarios:
      - **Complex multi-step processes**: Requiring structured control and flow.
      - **Dynamic content**: Generation with conditional logic (e.g., if/else).
      - **Systematic problem-solving**: Tasks requiring algorithmic precision.
      - **Template-based output**: Situations with variable content but fixed structure.
      - **Interactive behaviors**: Agents needing to respond to specific triggers or events.
    labels:
      - guidance
      - selection

  - name: pattern-selection-guide
    type: decision-guide
    brief: Choosing the right pattern for the task
    content: |
      | Pattern | Use When |
      |---------|----------|
      | **Handlebars** | Dynamic content and conditional rendering are needed. |
      | **Alg-speak** | Computational and algorithmic tasks must be defined precisely. |
      | **Annotation** | Iterative improvement processes (code review, design). |
      | **Symbolic logic** | Mathematical and logical reasoning is required. |
      | **Formal proof** | Rigorous logical verification of a statement is necessary. |
    labels:
      - decision-support
      - taxonomy

  - name: complexity-levels
    type: decision-guide
    brief: Assessing pattern complexity
    content: |
      | Level | Patterns | Examples |
      |-------|----------|----------|
      | **Basic** | Simple conditionals, direct templates | Linear algorithm steps |
      | **Intermediate** | Nested conditionals, complex iteration | Multi-step reasoning chains |
      | **Advanced** | Meta-level patterns, recursive structures | Formal logical specifications |
    labels:
      - complexity
      - pedagogy

  - name: troubleshooting-instructing
    type: error-handling
    brief: Common issues and fixes
    content: |
      If instructing patterns produce unexpected results:
      1. **Verify syntax** correctness against pattern specifications.
      2. **Check nesting** and closure of control structures (e.g., ensuring `{{/if}}` exists).
      3. **Validate data context** and variable availability (e.g., does `user.role` exist?).
      4. **Load detailed documentation** for the specific pattern being used.
    labels:
      - troubleshooting
      - debugging

  - name: algorithm-variants
    type: usage-guideline
    brief: Selecting algorithm specification styles
    content: |
      ### JavaScript (alg-javascript)
      Use when targeting web/Node.js environments, requiring modern ES6+ features, 
      or emphasizing functional programming patterns.

      ### Python (alg-python)
      Use when type safety and readability are paramount, requiring explicit type hints 
      and docstrings, or demonstrating Pythonic best practices.

      ### Flowchart (alg-flowchart)
      Use when visual clarity of algorithm flow is important for stakeholders who prefer 
      visual documentation or when illustrating complex decision trees.
    labels:
      - algorithm
      - selection
```