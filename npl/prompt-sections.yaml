name: prompt sections
brief: Tagged sections for structured content containment
description: |
  XML-style tagged sections for structured content containment and presentation in NPL.
purpose: |
  Tagged sections create specialized content blocks with specific formatting, processing, or display requirements. They structure and contain different types of content while providing semantic meaning about how that content should be interpreted or presented.
components:
  - name: example prompt section
    syntax: |
      <npl-prompt-section type="example">
      [___|example content]
      </npl-prompt-section>
    brief: Demonstrate usage patterns
    description: Provides clear demonstrations of syntax usage, behavior patterns, or expected outputs. Shows concrete implementations rather than abstract descriptions.
    labels:
      - content
      - demonstration
      - block
    require:
      - syntax.omission
    examples:
      - name: basic-example
        brief: Simple example section
        description: Demonstrates basic example block syntax.
        priority: 0
        purpose: Shows fundamental example section usage
        labels:
          - '<npl-prompt-section type="example">'
        example: |
          <npl-prompt-section type="example">
          Here's how to use highlight syntax: `important term`
          </npl-prompt-section>
      - name: example-with-application
        brief: Example guiding output
        description: Shows example content being applied to generate output.
        priority: 1
        purpose: Demonstrates example block influencing generation
        labels:
          - '<npl-prompt-section type="example">'
        thread:
          - role: system
            message: |
              <npl-prompt-section type="example">
              Input: "cat" ‚Üí Output: "CAT"
              Input: "dog" ‚Üí Output: "DOG"
              </npl-prompt-section>
              Apply to: "hello"
          - role: assistant
            message: |
              HELLO
      - name: multi-example-patterns
        brief: Multiple example patterns
        description: Multiple examples showing different patterns with expected output.
        priority: 2
        purpose: Demonstrates example blocks covering multiple cases
        labels:
          - '<npl-prompt-section type="example">'
          - "[...]"
        thread:
          - role: system
            message: |
              <npl-prompt-section type="example">
              Greeting: "Hi!" ‚Üí Response: "Hello! How can I help?"
              Question: "What time is it?" ‚Üí Response: "The current time is [...]. Is there anything else?"
              Farewell: "Bye" ‚Üí Response: "Goodbye! Have a great day!"
              </npl-prompt-section>
              User says: "See you later"
          - role: assistant
            message: |
              Goodbye! Have a great day!
  - name: note prompt section
    syntax: |
      <npl-prompt-section type="note">
      [___|note content]
      </npl-prompt-section>
    brief: Explanatory comments and context
    description: Includes explanatory comments, clarifications, warnings, or additional context within prompts without directly affecting generated output.
    labels:
      - content
      - documentation
      - block
    require:
      - syntax.omission
      - syntax.attention
    examples:
      - name: basic-note
        brief: Simple note section
        description: Demonstrates basic note block syntax.
        priority: 0
        purpose: Shows fundamental note section usage
        labels:
          - '<npl-prompt-section type="note">'
        example: |
          <npl-prompt-section type="note">
          The attention marker should be used sparingly to maintain its impact.
          </npl-prompt-section>
      - name: note-with-context
        brief: Note providing generation context
        description: Shows note providing context that influences output.
        priority: 1
        purpose: Demonstrates note affecting response behavior
        labels:
          - '<npl-prompt-section type="note">'
        thread:
          - role: system
            message: |
              <npl-prompt-section type="note">
              User prefers concise, technical responses. Avoid casual language.
              </npl-prompt-section>
              Explain what an API is.
          - role: assistant
            message: |
              An API (Application Programming Interface) defines protocols and tools for software components to communicate. It specifies request/response formats, authentication methods, and available endpoints.
      - name: multi-note-guidance
        brief: Multiple notes with attention
        description: Combines multiple notes with attention markers for comprehensive guidance.
        priority: 2
        purpose: Demonstrates notes with üéØ attention markers
        labels:
          - '<npl-prompt-section type="note">'
          - "üéØ <instruction>"
        thread:
          - role: system
            message: |
              <npl-prompt-section type="note">
              This API handles sensitive data.
              üéØ Never include raw credentials in responses.
              üéØ Always mask PII (show only last 4 digits).
              </npl-prompt-section>
              Show user profile for: email=john@test.com, ssn=123-45-6789, name=John Doe
          - role: assistant
            message: |
              **User Profile**
              - Name: John Doe
              - Email: j***@test.com
              - SSN: ***-**-6789
  - name: diagram prompt section
    syntax: |
      <npl-prompt-section type="diagram">
      [___|diagram content]
      </npl-prompt-section>
    brief: Visual representations and flowcharts
    description: |
      Contains visual representations, system architectures, flowcharts, and structural diagrams.
      Supports ASCII art, box-and-arrow, tree structures, and Mermaid syntax.

      Common uses:
      - Explaining content structure or relationships
      - Defining state machines for conversation or process flow
      - Documenting system architecture
      - Illustrating decision trees or workflows
    labels:
      - content
      - visual
      - block
    require:
      - syntax.omission
      - syntax.qualifier
    examples:
      - name: basic-diagram
        brief: Simple box-and-arrow
        description: Demonstrates basic diagram section with arrow notation.
        priority: 0
        purpose: Shows fundamental diagram syntax for explaining relationships
        labels:
          - '<npl-prompt-section type="diagram">'
          - "[A] --> [B]"
        example: |
          <npl-prompt-section type="diagram">
          [Component A] ---> [Component B]
          [Component B] ---> [Component C]
          </npl-prompt-section>
      - name: state-machine-conversation
        brief: State machine for conversation flow
        description: Defines a state machine that controls how the agent should navigate a conversation.
        priority: 0
        purpose: Shows diagram as behavioral instruction for conversation flow
        labels:
          - '<npl-prompt-section type="diagram">'
          - "state machine"
          - "[State] --event--> [State]"
        thread:
          - role: system
            message: |
              Follow this conversation state machine:
              <npl-prompt-section type="diagram">
              [GREETING] --user_responds--> [COLLECT_INFO]
              [COLLECT_INFO] --info_complete--> [CONFIRM]
              [COLLECT_INFO] --info_missing--> [COLLECT_INFO]
              [CONFIRM] --user_confirms--> [PROCESS]
              [CONFIRM] --user_corrects--> [COLLECT_INFO]
              [PROCESS] --success--> [COMPLETE]
              [PROCESS] --error--> [ERROR_HANDLING]
              [ERROR_HANDLING] --resolved--> [PROCESS]
              [ERROR_HANDLING] --unresolved--> [ESCALATE]
              </npl-prompt-section>
              Start in GREETING state. You are a pizza order assistant.
          - role: user
            message: Hi!
          - role: assistant
            message: |
              Welcome to Pizza Palace! I'd love to help you place an order.

              What type of pizza would you like today? (e.g., pepperoni, margherita, veggie)
          - role: user
            message: pepperoni, large
          - role: assistant
            message: |
              Great choice! Let me confirm your order:
              - Large Pepperoni Pizza

              Is this correct? Would you like to add anything else?
      - name: diagram-with-output
        brief: Diagram explaining a process
        description: Shows diagram used to describe a workflow that guides explanation output.
        priority: 1
        purpose: Demonstrates diagram for content explanation
        labels:
          - '<npl-prompt-section type="diagram">'
          - "[A] --> [B]"
        thread:
          - role: system
            message: |
              <npl-prompt-section type="diagram">
              [Input] --> [Validate] --> [Transform] --> [Output]
                              |
                              v
                          [Error]
              </npl-prompt-section>
              Describe this data pipeline.
          - role: assistant
            message: |
              This pipeline has four stages:
              1. **Input**: Data enters the system
              2. **Validate**: Data is checked for correctness; invalid data routes to Error handling
              3. **Transform**: Valid data is processed and converted
              4. **Output**: Transformed data is returned
      - name: multi-diagram-styles
        brief: Multiple diagram styles
        description: Combines box-arrow, tree, and Mermaid diagram styles.
        priority: 2
        purpose: Demonstrates various diagram notations together
        labels:
          - '<npl-prompt-section type="diagram">'
          - "[A] --> [B]"
          - "‚îú‚îÄ‚îÄ (tree)"
          - "flowchart (mermaid)"
        thread:
          - role: system
            message: |
              Show the same auth flow in three diagram styles:

              <npl-prompt-section type="diagram">
              Box-Arrow:
              [User] --> [Auth] --> [Dashboard]

              Tree:
              Auth System
              ‚îú‚îÄ‚îÄ Login
              ‚îÇ   ‚îú‚îÄ‚îÄ Username
              ‚îÇ   ‚îî‚îÄ‚îÄ Password
              ‚îî‚îÄ‚îÄ Session

              Mermaid:
              flowchart LR
                  U[User] --> A[Auth]
                  A --> D[Dashboard]
              </npl-prompt-section>
              Which style is clearest for documentation?
          - role: assistant
            message: |
              For documentation, Mermaid is typically clearest because:
              - Renders as proper graphics in supporting platforms
              - Supports labels, colors, and styling
              - More accessible than ASCII art

              However, box-arrow is best for quick inline explanations, and tree notation excels at showing hierarchies.
  - name: syntax prompt section
    syntax: |
      <npl-prompt-section type="syntax">
      [___|syntax definition]
      </npl-prompt-section>
    brief: Define formal syntax patterns
    description: Formally defines syntax patterns, grammar rules, and structural conventions. Provides standardized documentation for how syntax elements should be constructed.
    labels:
      - structure
      - definition
      - block
    require:
      - syntax.omission
      - syntax.qualifier
    examples:
      - name: basic-syntax
        brief: Simple syntax definition
        description: Demonstrates basic syntax section for defining patterns.
        priority: 0
        purpose: Shows fundamental syntax block usage
        labels:
          - '<npl-prompt-section type="syntax">'
        example: |
          <npl-prompt-section type="syntax">
          COMMAND := <action> <target> [--flag]
          </npl-prompt-section>
      - name: syntax-with-application
        brief: Syntax guiding generation
        description: Shows syntax definition being applied to generate valid output.
        priority: 1
        purpose: Demonstrates syntax block constraining output
        labels:
          - '<npl-prompt-section type="syntax">'
          - "<term>"
        thread:
          - role: system
            message: |
              <npl-prompt-section type="syntax">
              EMAIL := <local-part>@<domain>.<tld>
              </npl-prompt-section>
              Generate 3 example emails.
          - role: assistant
            message: |
              1. john.doe@example.com
              2. support@company.org
              3. user123@mail.net
      - name: multi-syntax-definitions
        brief: Multiple syntax patterns
        description: Combines multiple syntax definitions with examples.
        priority: 2
        purpose: Demonstrates comprehensive syntax documentation
        labels:
          - '<npl-prompt-section type="syntax">'
          - "<term>"
          - "[optional]"
        thread:
          - role: system
            message: |
              <npl-prompt-section type="syntax">
              DATE := <YYYY>-<MM>-<DD>
              TIME := <HH>:<MM>[:<SS>]
              DATETIME := <DATE>T<TIME>[Z|<offset>]
              </npl-prompt-section>
              Parse: "Meeting at 2024-03-15T14:30"
          - role: assistant
            message: |
              Parsed components:
              - DATE: 2024-03-15 (YYYY=2024, MM=03, DD=15)
              - TIME: 14:30 (HH=14, MM=30, SS omitted)
              - DATETIME: 2024-03-15T14:30 (no timezone specified)
  - name: format prompt section
    syntax: |
      <npl-prompt-section type="format">
      [___|format specification]
      </npl-prompt-section>
    brief: Specify output templates and structure
    description: Specifies exact structure and layout of expected output including template patterns, data organization, and formatting requirements.
    labels:
      - structure
      - template
      - block
    require:
      - syntax.omission
      - syntax.qualifier
    examples:
      - name: basic-format
        brief: Simple output format
        description: Demonstrates basic format section with placeholders and in-fill.
        priority: 0
        purpose: Shows fundamental format block usage
        labels:
          - '<npl-prompt-section type="format">'
          - "<term>"
          - "[...]"
        example: |
          <npl-prompt-section type="format">
          Hello <user.name>,
          Did you know [...|funny factoid].

          Have a great day!
          </npl-prompt-section>
      - name: format-with-output
        brief: Format shaping response
        description: Shows format specification producing structured output.
        priority: 1
        purpose: Demonstrates format constraining output structure
        labels:
          - '<npl-prompt-section type="format">'
          - "<term>"
          - "[...]"
        thread:
          - role: system
            message: |
              <npl-prompt-section type="format">
              **Weather Report**
              Location: <city>
              Temperature: [...|current temp]
              Conditions: [...|weather description]
              </npl-prompt-section>
              Weather for: Tokyo
          - role: assistant
            message: |
              **Weather Report**
              Location: Tokyo
              Temperature: 18¬∞C (64¬∞F)
              Conditions: Partly cloudy with light winds from the east
      - name: complex-format
        brief: Format with tables and iteration
        description: Combines table format with foreach iteration patterns.
        priority: 2
        purpose: Demonstrates advanced format with multiple elements
        labels:
          - '<npl-prompt-section type="format">'
          - "<term>"
          - "[...]"
          - "{{foreach}}"
        thread:
          - role: system
            message: |
              <npl-prompt-section type="format">
              # <report.title>

              | Metric | Value | Change |
              |--------|-------|--------|
              {{foreach metrics as m}}
              | {{m.name}} | {{m.value}} | {{m.delta}} |
              {{/foreach}}

              Summary: [...:1-2sentences]
              </npl-prompt-section>
              Generate quarterly sales report.
          - role: assistant
            message: |
              # Q4 Sales Report

              | Metric | Value | Change |
              |--------|-------|--------|
              | Revenue | $2.4M | +12% |
              | Units Sold | 15,420 | +8% |
              | New Customers | 892 | +23% |

              Summary: Q4 showed strong growth across all metrics, with new customer acquisition leading at 23% improvement over Q3.
  - name: template prompt section
    syntax: |
      <npl-prompt-section type="template">
      [___|template with placeholders]
      </npl-prompt-section>
    brief: Reusable output patterns
    description: Defines reusable output formats with placeholder substitution, conditional logic, and iteration patterns using handlebars-style syntax.
    labels:
      - structure
      - reusable
      - block
    require:
      - syntax.omission
      - syntax.placeholder
      - syntax.qualifier
    examples:
      - name: basic-template
        brief: Simple placeholder template
        description: Demonstrates basic template with placeholders.
        priority: 0
        purpose: Shows fundamental template syntax
        labels:
          - '<npl-prompt-section type="template">'
          - "{term}"
        example: |
          <npl-prompt-section type="template">
          # {user.name}
          **Role**: {user.role}
          **Email**: {user.email}
          </npl-prompt-section>
      - name: template-with-output
        brief: Template with data substitution
        description: Shows template producing output from provided data.
        priority: 1
        purpose: Demonstrates template placeholder substitution
        labels:
          - '<npl-prompt-section type="template">'
          - "{term}"
          - "{foreach}"
        thread:
          - role: system
            message: |
              <npl-prompt-section type="template">
              | Name | Score |
              |------|-------|
              {foreach students as s}
              | {s.name} | {s.score} |
              {/foreach}
              </npl-prompt-section>
              Data: [{name: "Alice", score: 95}, {name: "Bob", score: 87}]
          - role: assistant
            message: |
              | Name | Score |
              |------|-------|
              | Alice | 95 |
              | Bob | 87 |
      - name: complex-template
        brief: Conditional and nested iteration
        description: Combines if/else logic with foreach and context variables.
        priority: 2
        purpose: Demonstrates advanced template features
        labels:
          - '<npl-prompt-section type="template">'
          - "{term}"
          - "{foreach}"
          - "{if}/{else}"
          - "@last"
        thread:
          - role: system
            message: |
              <npl-prompt-section type="template">
              {if items}
              Items: {foreach items as i}{i.name}{if not @last}, {/if}{/foreach}
              {else}
              No items found.
              {/if}
              </npl-prompt-section>
              Data: {items: [{name: "A"}, {name: "B"}, {name: "C"}]}
          - role: assistant
            message: |
              Items: A, B, C
  - name: alg prompt section
    syntax: |
      <npl-prompt-section type="alg">
      name: <algorithm-name>
      input: <input specification>
      output: <output specification>

      procedure <name>(<params>):
        [___|algorithmic steps]
      </npl-prompt-section>
    brief: Formal algorithm specifications
    description: |
      Structured way to specify computational procedures with named algorithms, input/output specifications,
      and step-by-step procedural logic. Use alg blocks to instruct the LLM on exactly how to process
      requests or handle specific tasks algorithmically.
    labels:
      - algorithm
      - formal
      - block
    require:
      - syntax.omission
      - syntax.qualifier
    examples:
      - name: alg-request-handler
        brief: Algorithm instructing request processing
        description: Uses algorithm specification to instruct the LLM on how to handle user requests.
        priority: 0
        purpose: Shows algorithm as behavioral instruction for request handling
        labels:
          - '<npl-prompt-section type="alg">'
          - "procedure"
          - "behavioral"
        thread:
          - role: system
            message: |
              Handle all user questions using this algorithm:
              <npl-prompt-section type="alg">
              name: AnswerQuestion
              input: user_question, context
              output: structured_response

              procedure AnswerQuestion(question, context):
                # Step 1: Classify the question type
                qtype = classify(question, [factual, opinion, how-to, clarification])

                # Step 2: Check if answerable from context
                if qtype == factual:
                  evidence = search_context(context, question)
                  if evidence is empty:
                    return "I don't have information about that in the provided context."
                  return synthesize_answer(evidence)

                if qtype == how-to:
                  steps = extract_procedure(context, question)
                  return format_as_numbered_list(steps)

                if qtype == clarification:
                  return ask_followup(question)

                # Default: opinion or unsupported
                return "I can help with factual questions about the provided context."
              </npl-prompt-section>
          - role: user
            message: |
              Context: "Python lists are mutable sequences. Use append() to add items, pop() to remove the last item, and remove(x) to delete the first occurrence of x."

              Question: How do I add an item to a Python list?
          - role: assistant
            message: |
              To add an item to a Python list:

              1. Use the `append()` method
              2. Call it on your list with the item to add: `my_list.append(item)`

              This adds the item to the end of the list.
      - name: alg-with-trace
        brief: Algorithm with execution trace
        description: Shows algorithm specification with traced execution.
        priority: 1
        purpose: Demonstrates algorithm guiding computation
        labels:
          - '<npl-prompt-section type="alg">'
          - "procedure"
        thread:
          - role: system
            message: |
              Use this algorithm for calculating GCD:
              <npl-prompt-section type="alg">
              name: gcd
              input: integers a, b
              output: greatest common divisor

              procedure gcd(a, b):
                while b != 0:
                  temp = b
                  b = a mod b
                  a = temp
                return a
              </npl-prompt-section>
              Show your work step by step.
          - role: user
            message: What is the GCD of 48 and 18?
          - role: assistant
            message: |
              Applying gcd(48, 18):
              - a=48, b=18 ‚Üí temp=18, b=48 mod 18=12, a=18
              - a=18, b=12 ‚Üí temp=12, b=18 mod 12=6, a=12
              - a=12, b=6 ‚Üí temp=6, b=12 mod 6=0, a=6
              - b=0, return a=6

              **Result**: gcd(48, 18) = 6
      - name: multi-procedure-alg
        brief: Multiple procedures for complex task
        description: Combines multiple procedures to instruct multi-step processing.
        priority: 2
        purpose: Demonstrates complex algorithm specification for behavior
        labels:
          - '<npl-prompt-section type="alg">'
          - "procedure (multiple)"
          - "behavioral"
        thread:
          - role: system
            message: |
              Process code review requests using this algorithm:
              <npl-prompt-section type="alg">
              name: CodeReview
              input: code_snippet, language
              output: review_report

              procedure CodeReview(code, lang):
                issues = []
                suggestions = []

                # Phase 1: Static analysis
                issues += check_syntax(code, lang)
                issues += check_security(code, lang)
                issues += check_style(code, lang)

                # Phase 2: Logic review
                suggestions += analyze_complexity(code)
                suggestions += check_edge_cases(code)

                # Phase 3: Format output
                return format_review(issues, suggestions)

              procedure format_review(issues, suggestions):
                output = "## Code Review\n\n"
                if issues:
                  output += "### Issues Found\n"
                  for issue in issues:
                    output += "- " + issue.severity + ": " + issue.description + "\n"
                if suggestions:
                  output += "### Suggestions\n"
                  for s in suggestions:
                    output += "- " + s + "\n"
                return output
              </npl-prompt-section>
          - role: user
            message: |
              Review this Python code:
              ```python
              def divide(a, b):
                return a / b
              ```
          - role: assistant
            message: |
              ## Code Review

              ### Issues Found
              - **Warning**: No handling for division by zero (ZeroDivisionError)
              - **Style**: Missing type hints for parameters and return value
              - **Style**: Missing docstring

              ### Suggestions
              - Add parameter validation: `if b == 0: raise ValueError("Cannot divide by zero")`
              - Consider returning `None` or a default value for invalid input
              - Add type hints: `def divide(a: float, b: float) -> float:`
  - name: alg-pseudo prompt section
    syntax: |
      <npl-prompt-section type="alg-pseudo">
      Algorithm: <name>
      Input: <input>
      Output: <output>

      BEGIN
        [___|pseudocode steps]
      END
      </npl-prompt-section>
    brief: Pseudocode algorithm descriptions
    description: |
      Natural language approach to algorithm specification using BEGIN/END, IF/THEN/ELSE, FOR/WHILE loops.
      Focuses on logical flow rather than implementation details. Use pseudocode to instruct the LLM
      on how to handle processes in a readable, language-agnostic way.
    labels:
      - algorithm
      - pseudocode
      - block
    require:
      - syntax.omission
      - syntax.qualifier
    examples:
      - name: pseudo-conversation-handler
        brief: Pseudocode instructing conversation flow
        description: Uses pseudocode to instruct the LLM on how to handle a multi-turn conversation.
        priority: 0
        purpose: Shows pseudocode as behavioral instruction for conversation handling
        labels:
          - '<npl-prompt-section type="alg-pseudo">'
          - "BEGIN/END"
          - "IF/THEN"
          - "behavioral"
        thread:
          - role: system
            message: |
              Handle customer support conversations using this algorithm:
              <npl-prompt-section type="alg-pseudo">
              Algorithm: CustomerSupport
              Input: user_message, conversation_history
              Output: response

              BEGIN
                intent = CLASSIFY user_message AS [greeting, question, complaint, farewell, other]

                IF intent is greeting THEN
                  RETURN friendly greeting + ask how to help
                END IF

                IF intent is question THEN
                  answer = SEARCH knowledge_base FOR user_message
                  IF answer found THEN
                    RETURN answer + ask if more help needed
                  ELSE
                    RETURN apologize + offer to escalate to human
                  END IF
                END IF

                IF intent is complaint THEN
                  RETURN empathize + apologize + ask for details + offer solution
                END IF

                IF intent is farewell THEN
                  RETURN thank user + wish well + close conversation
                END IF

                RETURN ask for clarification
              END
              </npl-prompt-section>
          - role: user
            message: My order never arrived and I'm really frustrated!
          - role: assistant
            message: |
              I completely understand your frustration, and I'm truly sorry your order hasn't arrived. That's definitely not the experience we want you to have.

              Could you please share your order number so I can look into this right away? Once I have that, I can check the shipping status and work with you on a solution‚Äîwhether that's tracking down the package, reshipping your order, or processing a refund.
      - name: pseudo-with-execution
        brief: Pseudocode with execution trace
        description: Shows pseudocode being executed step by step.
        priority: 1
        purpose: Demonstrates pseudocode guiding computation
        labels:
          - '<npl-prompt-section type="alg-pseudo">'
          - "BEGIN/END"
          - "FOR/DO"
        thread:
          - role: system
            message: |
              Use this algorithm and show your work:
              <npl-prompt-section type="alg-pseudo">
              Algorithm: SumArray
              Input: Array A of numbers
              Output: Sum of all elements

              BEGIN
                total = 0
                FOR each element x in A DO
                  total = total + x
                END FOR
                RETURN total
              END
              </npl-prompt-section>
          - role: user
            message: Calculate the sum of [3, 7, 2]
          - role: assistant
            message: |
              Execution trace:
              - Initialize: total = 0
              - x = 3: total = 0 + 3 = 3
              - x = 7: total = 3 + 7 = 10
              - x = 2: total = 10 + 2 = 12
              - RETURN 12

              **Result**: 12
      - name: complex-pseudo
        brief: Multi-branch request processing
        description: Uses pseudocode to instruct handling of different request types with error cases.
        priority: 2
        purpose: Demonstrates complex pseudocode for request handling
        labels:
          - '<npl-prompt-section type="alg-pseudo">'
          - "BEGIN/END"
          - "IF/ELSE IF/ELSE"
          - "WHILE/DO"
          - "behavioral"
        thread:
          - role: system
            message: |
              Process data validation requests using this algorithm:
              <npl-prompt-section type="alg-pseudo">
              Algorithm: ValidateAndProcess
              Input: data, schema
              Output: result or error_list

              BEGIN
                errors = empty list

                # Phase 1: Required field check
                FOR each field in schema.required DO
                  IF field NOT IN data THEN
                    ADD "Missing required field: {field}" TO errors
                  END IF
                END FOR

                IF errors is NOT empty THEN
                  RETURN errors
                END IF

                # Phase 2: Type validation
                FOR each field, value IN data DO
                  expected_type = schema.types[field]
                  IF type(value) != expected_type THEN
                    ADD "Invalid type for {field}: expected {expected_type}" TO errors
                  END IF
                END FOR

                IF errors is NOT empty THEN
                  RETURN errors
                END IF

                # Phase 3: Process valid data
                RETURN process(data)
              END
              </npl-prompt-section>
          - role: user
            message: |
              Validate: {"name": "Alice", "age": "thirty"}
              Schema: required=[name, age, email], types={name: string, age: integer, email: string}
          - role: assistant
            message: |
              **Phase 1: Required field check**
              - name: present ‚úì
              - age: present ‚úì
              - email: NOT present ‚úó ‚Üí Error: "Missing required field: email"

              **Result**: Validation failed

              Errors:
              - Missing required field: email

              (Note: Type validation for age="thirty" would also fail in Phase 2, but we return early after Phase 1 errors)
  - name: artifact prompt section
    syntax: |
      <artifact type="{content-type}">
      <title><title></title>
      <content>
      [___|artifact content]
      </content>
      </artifact>
    brief: Structured output with metadata
    description: Provides structured output requiring special handling, metadata attachment, or specific rendering contexts. Supports SVG, code, documents with type-specific parameters.
    labels:
      - special
      - metadata
      - block
    require:
      - syntax.omission
      - syntax.qualifier
    examples:
      - name: basic-artifact
        brief: Simple code artifact
        description: Demonstrates basic artifact fence with type and metadata.
        priority: 0
        purpose: Shows fundamental artifact block
        labels:
          - "```artifact"
          - "type:"
          - "title:"
        example: |
          ```artifact
          type: code
          language: python
          title: "Hello World"
          print("Hello, World!")
          ```
      - name: artifact-with-output
        brief: Artifact generation from request
        description: Shows artifact being generated in response to a request.
        priority: 1
        purpose: Demonstrates artifact creation in context
        labels:
          - "```artifact"
          - "type:"
          - "title:"
        thread:
          - role: system
            message: |
              Generate an SVG artifact when asked for graphics.
          - role: user
            message: Draw a red square.
          - role: assistant
            message: |
              ```artifact
              type: svg
              title: "Red Square"
              <svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
                <rect x="10" y="10" width="80" height="80" fill="red" />
              </svg>
              ```
      - name: multi-artifact
        brief: Multiple artifact types
        description: Shows different artifact types being used together.
        priority: 2
        purpose: Demonstrates various artifact type options
        labels:
          - "```artifact"
          - "type: code"
          - "type: svg"
          - "type: document"
        thread:
          - role: system
            message: |
              Respond with appropriate artifact types:
              - Code requests ‚Üí type: code
              - Graphics ‚Üí type: svg
              - Documents ‚Üí type: document
          - role: user
            message: Create a function to add two numbers, then show it as a flowchart.
          - role: assistant
            message: |
              ```artifact
              type: code
              language: python
              title: "Add Function"
              def add(a, b):
                  return a + b
              ```

              ```artifact
              type: svg
              title: "Add Flowchart"
              <svg viewBox="0 0 200 150" xmlns="http://www.w3.org/2000/svg">
                <rect x="50" y="10" width="100" height="30" fill="#e0e0e0" stroke="#333"/>
                <text x="100" y="30" text-anchor="middle">Input a, b</text>
                <rect x="50" y="60" width="100" height="30" fill="#e0e0e0" stroke="#333"/>
                <text x="100" y="80" text-anchor="middle">sum = a + b</text>
                <rect x="50" y="110" width="100" height="30" fill="#e0e0e0" stroke="#333"/>
                <text x="100" y="130" text-anchor="middle">Return sum</text>
                <line x1="100" y1="40" x2="100" y2="60" stroke="#333"/>
                <line x1="100" y1="90" x2="100" y2="110" stroke="#333"/>
              </svg>
              ```
  - name: handlebars-instructions
    syntax:
      - name: conditional-block
        syntax: |
          {{if <condition>}}
            [content if true]
          {{else}}
            [content if false]
          {{/if}}
      - name: iteration-block
        syntax: |
          {{foreach <collection> as <item>}}
            [content for each item]
          {{/foreach}}
      - name: unless-block
        syntax: |
          {{unless <condition>}}
            [content if condition is false]
          {{/unless}}
    brief: Template-like control structures for dynamic content
    description: |
      Handlebars-like syntax used to instruct agents on how to process requests and format output.
      It provides a familiar templating grammar for conditional rendering, iteration over collections,
      and dynamic content inclusion based on context.
    purpose: |
      Generate repetitive content with variations, apply conditional logic to output sections,
      or iterate over datasets without writing imperative code.
    labels:
      - block
      - logic
      - template
    require:
      - syntax.placeholder
      - syntax.in-fill
    examples:
      - name: conditional-logic
        brief: Conditional rendering based on user role
        priority: 0
        example: |
          {{if user.role == 'administrator'}}
            Show admin panel
          {{else}}
            Show user dashboard
          {{/if}}
      - name: iteration-loop
        brief: Iterating over a list of executives
        priority: 0
        example: |
          {{foreach business.executives as executive}}
          - Name: {{executive.name}}
          - Role: {{executive.role}}
          {{/foreach}}

  - name: algorithm-specification
    syntax:
      - name: generic-algorithm
        syntax: |
          ```alg
          [algorithm specification]
          ```
      - name: pseudocode-algorithm
        syntax: |
          ```alg-pseudo
          [pseudocode implementation]
          ```
      - name: language-specific-algorithm
        syntax: |
          ```alg-<language>
          [language-specific implementation]
          ```
      - name: flowchart-representation
        syntax: |
          ```alg-flowchart
          mermaid
          [flowchart definition]
          ```
    brief: Structured language for defining computational logic
    description: |
      Algorithm Specification Language (Alg-Speak) provides formal notation for expressing
      computational logic, step-by-step procedures, and algorithmic thinking patterns.
      It supports generic pseudocode, language-specific implementations, and flowchart visualizations.
    purpose: |
      Define precise computational procedures, document complex logic flows, or specify
      algorithm implementations when exact processing steps are critical.
    labels:
      - block
      - definition
      - algorithm
    examples:
      - name: find-max-algorithm
        brief: Finding the maximum value in an array
        priority: 1
        example: |
          ```alg
          Algorithm: FindMaximum(array A)
          1. max ‚Üê A[0]
          2. for i = 1 to length(A) - 1 do
          3.   if A[i] > max then
          4.     max ‚Üê A[i]
          5.   end if
          6. end for
          7. return max
          ```
      - name: binary-search-pseudo
        brief: Binary search implementation in pseudocode
        priority: 1
        example: |
          ```alg-pseudo
          PROCEDURE BinarySearch(array, target):
            left = 0
            right = array.length - 1
            WHILE left <= right:
              mid = (left + right) / 2
              IF array[mid] = target:
                RETURN mid
              ELSE IF array[mid] < target:
                left = mid + 1
              ELSE:
                right = mid - 1
              END IF
            END WHILE
            RETURN -1
          ```

  - name: iterative-annotation
    syntax:
      - name: basic-refinement
        syntax: |
          ```annotation
          original: [existing content]
          issues: [identified problems]
          refinement: [improved version]
          ```
      - name: cyclic-refinement
        syntax: |
          ```annotation-cycle
          iteration: <number>
          focus: <area of improvement>
          changes: [specific modifications]
          validation: [verification method]
          ```
    brief: Progressive refinement patterns for code and design
    description: |
      Annotation patterns enable systematic improvement of outputs through iterative cycles.
      They provide a structured format for documenting original content, identifying issues,
      and tracking refinement versions.
    purpose: |
      Conduct code review and improvement cycles, UX design iteration processes, or
      progressive solution refinement where feedback loops are required.
    labels:
      - block
      - guidance
      - refinement
    examples:
      - name: code-refinement
        brief: Improving a calculation function
        priority: 1
        example: |
          ```annotation
          original: |
            function calculate(a, b) {
              return a + b;
            }
          issues:
            - No input validation
            - Limited to addition only
          refinement: |
            function calculate(a, b, operation = 'add') {
              if (typeof a !== 'number' || typeof b !== 'number') {
                throw new Error('Invalid input: numbers required');
              }
              // ... switch case logic
            }
          ```

  - name: formal-proof
    syntax:
      - name: proof-structure
        syntax: |
          ```proof
          Given: [premises]
          To Prove: [conclusion]
          Proof:
            1. [step] - [justification]
            ...
            n. [conclusion] - [final justification]
          ```
    brief: Structured frameworks for rigorous logical verification
    description: |
      Formal proof structures provide systematic frameworks for constructing valid logical
      arguments and establishing the truth of statements through step-by-step reasoning and
      inference rules.
    purpose: |
      Verify mathematical theorems, prove algorithm correctness, or verify system properties
      where logical soundness must be demonstrated.
    labels:
      - block
      - verification
      - formal
    examples:
      - name: direct-proof
        brief: Proving if n is even then n¬≤ is even
        priority: 2
        example: |
          ```proof
          Theorem: If n is even, then n¬≤ is even.
          Given: n is even (n = 2k for some integer k)
          To Prove: n¬≤ is even

          Proof:
          1. n = 2k - Given (n is even)
          2. n¬≤ = (2k)¬≤ - Substitution
          3. n¬≤ = 4k¬≤ - Algebraic manipulation
          4. n¬≤ = 2(2k¬≤) - Factoring
          5. Therefore, n¬≤ is even - Definition of even number ‚àé
          ```

  - name: symbolic-logic
    syntax: |
      <npl-prompt-section type="logic">
      [___|propositional or predicate logic expressions]
      </npl-prompt-section>
    brief: Formal logical expressions
    description: |
      Propositional and first-order predicate logic for precise behavioral specifications
      using quantifiers (‚àÄ, ‚àÉ), connectives (‚àß, ‚à®, ‚Üí, ‚Üî, ¬¨), and predicates.

      Two primary uses:
      - **Behavioral instruction**: Define rules the agent must follow when processing requests
      - **State description**: Formally specify the current state of a system or entity
    labels:
      - logic
      - formal
      - block
    require:
      - syntax.omission
      - syntax.qualifier
    examples:
      - name: logic-behavioral-instruction
        brief: Logic defining agent behavior rules
        description: Uses logic to instruct the agent on how to handle different request types.
        priority: 0
        purpose: Shows logic as behavioral instruction for request processing
        labels:
          - '<npl-prompt-section type="logic">'
          - "‚àÄ ‚Üí"
          - "behavioral"
        thread:
          - role: system
            message: |
              Process requests according to these rules:
              <npl-prompt-section type="logic">
              ‚àÄrequest (
                (Authenticated(user) ‚àß Authorized(user, request.resource)) ‚Üí Allow(request)
              )
              ‚àÄrequest (
                ¬¨Authenticated(user) ‚Üí Respond(401, "Authentication required")
              )
              ‚àÄrequest (
                Authenticated(user) ‚àß ¬¨Authorized(user, request.resource) ‚Üí Respond(403, "Forbidden")
              )
              </npl-prompt-section>
          - role: user
            message: |
              User "bob" (authenticated, role=viewer) requests DELETE /api/posts/123
              Resource /api/posts requires role=admin for DELETE
          - role: assistant
            message: |
              Evaluating request:
              - Authenticated(bob) = TRUE
              - Authorized(bob, DELETE /api/posts/123) = FALSE (viewer ‚â† admin)

              Applying rule 3: Authenticated ‚àß ¬¨Authorized ‚Üí Respond(403)

              **Response**: 403 Forbidden
      - name: logic-state-description
        brief: Logic describing system state
        description: Uses logic to formally specify the current state of a system.
        priority: 0
        purpose: Shows logic as state description for system modeling
        labels:
          - '<npl-prompt-section type="logic">'
          - "‚àß ‚à®"
          - "state"
        thread:
          - role: system
            message: |
              Current system state:
              <npl-prompt-section type="logic">
              # Cart State
              CartExists(user_123) ‚àß ItemCount(cart_123, 3)
              ‚àÄitem ‚àà cart_123: InStock(item)

              # User State
              Authenticated(user_123) ‚àß ¬¨PremiumMember(user_123)
              ShippingAddress(user_123) = NULL

              # Checkout Preconditions
              CanCheckout(user) ‚Üî (CartExists(user) ‚àß ItemCount(cart, n) where n > 0
                                   ‚àß ShippingAddress(user) ‚â† NULL)
              </npl-prompt-section>
              Can user_123 proceed to checkout?
          - role: assistant
            message: |
              Evaluating CanCheckout(user_123):
              - CartExists(user_123) = TRUE ‚úì
              - ItemCount(cart_123, 3) where 3 > 0 = TRUE ‚úì
              - ShippingAddress(user_123) = NULL ‚úó

              **Result**: Cannot checkout. ShippingAddress is required.

              Prompt user to add a shipping address before proceeding.
      - name: logic-with-evaluation
        brief: Logic expression evaluation
        description: Shows logical expression being evaluated with classical inference.
        priority: 1
        purpose: Demonstrates logic constraining reasoning
        labels:
          - '<npl-prompt-section type="logic">'
          - "‚àÄ ‚àÉ"
          - "‚Üí"
        thread:
          - role: system
            message: |
              <npl-prompt-section type="logic">
              ‚àÄx (Human(x) ‚Üí Mortal(x))
              Human(Socrates)
              </npl-prompt-section>
              What can we conclude?
          - role: assistant
            message: |
              By modus ponens:
              1. ‚àÄx (Human(x) ‚Üí Mortal(x)) ‚Äî universal rule
              2. Human(Socrates) ‚Äî given fact
              3. Human(Socrates) ‚Üí Mortal(Socrates) ‚Äî instantiation
              4. Mortal(Socrates) ‚Äî conclusion

              Socrates is mortal.
      - name: complex-logic
        brief: Nested quantifiers and predicates
        description: Combines universal and existential quantifiers with multiple predicates for complex request handling.
        priority: 2
        purpose: Demonstrates complex logical specifications for behavior
        labels:
          - '<npl-prompt-section type="logic">'
          - "‚àÄ ‚àÉ"
          - "‚àß ‚Üí ¬¨"
        thread:
          - role: system
            message: |
              Handle requests using these rules:
              <npl-prompt-section type="logic">
              ‚àÄrequest (Received(request) ‚Üí
                (Valid(request) ‚Üí Process(request)) ‚àß
                (¬¨Valid(request) ‚Üí Reject(request)))

              ‚àÄx (Admin(x) ‚Üí ‚àÄr (Request(r, x) ‚Üí Valid(r)))
              </npl-prompt-section>
              Trace: Received(r1), Request(r1, alice), Admin(alice)
          - role: assistant
            message: |
              Trace:
              1. Admin(alice) ‚Üí ‚àÄr (Request(r, alice) ‚Üí Valid(r))
              2. Request(r1, alice) ‚Üí Valid(r1)
              3. Valid(r1)
              4. Received(r1) ‚àß Valid(r1) ‚Üí Process(r1)

              Result: Process(r1) ‚Äî request is processed.
  - name: higher-order-logic
    syntax: |
      <npl-prompt-section type="higher-order-logic">
      [___|higher-order logic expressions]
      </npl-prompt-section>
    brief: Higher-order logical specifications
    description: |
      Second-order and higher-order logic supporting quantification over predicates, functions, and sets.
      Enables meta-level reasoning and complex behavioral constraints.

      Two primary uses:
      - **Behavioral instruction**: Define transformation rules, processing pipelines, or meta-level policies
      - **State description**: Model complex system states involving relationships between types, functions, or predicates
    labels:
      - logic
      - formal
      - higher-order
      - block
    require:
      - syntax.omission
      - syntax.qualifier
    examples:
      - name: hol-behavioral-instruction
        brief: Higher-order logic defining transformation pipeline
        description: Uses higher-order logic to instruct the agent on how to process and transform data.
        priority: 0
        purpose: Shows higher-order logic as behavioral instruction for data processing
        labels:
          - '<npl-prompt-section type="higher-order-logic">'
          - "‚àÄf ‚àÄg"
          - "behavioral"
        thread:
          - role: system
            message: |
              Process user input using this transformation pipeline:
              <npl-prompt-section type="higher-order-logic">
              # Define pipeline composition
              Pipeline ‚âî Œªstages. fold(‚àò, id, stages)

              # Validation stage type
              Validator: (Input ‚Üí Result<Input, Error>)

              # Transformation stages
              ‚àÄinput: UserInput
                Pipeline([Sanitize, Validate, Normalize, Transform])(input)
                where
                  Sanitize: String ‚Üí String       # Remove dangerous chars
                  Validate: String ‚Üí Result<String, ValidationError>
                  Normalize: String ‚Üí String      # Lowercase, trim
                  Transform: String ‚Üí OutputType  # Convert to target type

              # Error handling rule
              ‚àÄstage ‚àÄinput (stage(input) = Error(e) ‚Üí Halt ‚àß Return(e))
              </npl-prompt-section>
          - role: user
            message: 'Process input: "  HELLO@Example.com  "'
          - role: assistant
            message: |
              Applying pipeline:
              1. **Sanitize**: "  HELLO@Example.com  " ‚Üí "  HELLO@Example.com  " (no dangerous chars)
              2. **Validate**: Valid email format ‚úì
              3. **Normalize**: "  HELLO@Example.com  " ‚Üí "hello@example.com"
              4. **Transform**: Output as Email type

              **Result**: `Email("hello@example.com")`
      - name: hol-state-description
        brief: Higher-order logic describing system capabilities
        description: Uses higher-order logic to formally model system state and capabilities.
        priority: 0
        purpose: Shows higher-order logic as state description for capability modeling
        labels:
          - '<npl-prompt-section type="higher-order-logic">'
          - "‚àÄP ‚àÉ"
          - "state"
        thread:
          - role: system
            message: |
              Current plugin system state:
              <npl-prompt-section type="higher-order-logic">
              # Registered capabilities (predicates over operations)
              Capabilities: Set<(Operation ‚Üí Bool)>

              # Current state
              RegisteredPlugins = {ImageProcessor, TextAnalyzer, DataExporter}

              ‚àÄp ‚àà RegisteredPlugins: ‚àÉcapability ‚àà Capabilities (p.provides = capability)

              ImageProcessor.provides = Œªop. op ‚àà {Resize, Crop, Filter}
              TextAnalyzer.provides = Œªop. op ‚àà {Summarize, Translate, Sentiment}
              DataExporter.provides = Œªop. op ‚àà {ToCSV, ToJSON, ToXML}

              # System can perform operation iff some plugin provides it
              CanPerform(op) ‚Üî ‚àÉp ‚àà RegisteredPlugins (p.provides(op))
              </npl-prompt-section>
              Can the system perform Translate? What about Compress?
          - role: assistant
            message: |
              Evaluating capabilities:

              **Translate**:
              - TextAnalyzer.provides(Translate) = TRUE (Translate ‚àà {Summarize, Translate, Sentiment})
              - ‚àÉp where p.provides(Translate) ‚úì
              - **CanPerform(Translate) = TRUE**

              **Compress**:
              - ImageProcessor.provides(Compress) = FALSE
              - TextAnalyzer.provides(Compress) = FALSE
              - DataExporter.provides(Compress) = FALSE
              - ¬¨‚àÉp where p.provides(Compress)
              - **CanPerform(Compress) = FALSE**

              The system can Translate but cannot Compress. A compression plugin would need to be registered.
      - name: hol-with-interpretation
        brief: Higher-order logic expression interpretation
        description: Shows higher-order logic expression being interpreted.
        priority: 1
        purpose: Demonstrates higher-order logic guiding reasoning
        labels:
          - '<npl-prompt-section type="higher-order-logic">'
          - "‚àÄf: (A ‚Üí B)"
          - "‚àÉ"
        thread:
          - role: system
            message: |
              <npl-prompt-section type="higher-order-logic">
              ‚àÄf: (A ‚Üí B) ‚àÄg: (B ‚Üí C) ‚àÉh: (A ‚Üí C) (h = g ‚àò f)
              </npl-prompt-section>
              Given f: Int ‚Üí String (toString) and g: String ‚Üí Bool (isEmpty), what is h?
          - role: assistant
            message: |
              By function composition:
              - f: Int ‚Üí String (converts int to string)
              - g: String ‚Üí Bool (checks if empty)
              - h = g ‚àò f: Int ‚Üí Bool

              h(n) = isEmpty(toString(n))

              For any integer n, h returns whether its string representation is empty (always false for valid integers).
      - name: complex-hol
        brief: Polymorphic type reasoning
        description: Combines type variables with function quantification.
        priority: 2
        purpose: Demonstrates advanced higher-order logic specifications
        labels:
          - '<npl-prompt-section type="higher-order-logic">'
          - "‚àÄŒ± ‚àÄŒ≤"
          - "‚àÄf: (Œ± ‚Üí Œ≤)"
        thread:
          - role: system
            message: |
              <npl-prompt-section type="higher-order-logic">
              ‚àÄŒ± ‚àÄŒ≤ ‚àÄf: (Œ± ‚Üí Œ≤) ‚àÄg: (Œ≤ ‚Üí Œ±)
                (‚àÄx: Œ± (g(f(x)) = x)) ‚àß (‚àÄy: Œ≤ (f(g(y)) = y)) ‚Üí
                Isomorphic(Œ±, Œ≤)
              </npl-prompt-section>
              Are Int and String isomorphic?
          - role: assistant
            message: |
              Checking isomorphism conditions:

              **Needed**: f: Int ‚Üí String and g: String ‚Üí Int such that:
              1. g(f(x)) = x for all Int x
              2. f(g(y)) = y for all String y

              **Analysis**:
              - f = toString works for condition 1 (parseInt(toString(5)) = 5)
              - Condition 2 fails: toString(parseInt("hello")) ‚â† "hello"

              **Conclusion**: Int and String are NOT isomorphic. Not all strings are valid integer representations.
  - name: symbolic-latex
    syntax: |
      <npl-prompt-section type="symbolic-latex">
      [___|mathematical instructions using LaTeX notation]
      </npl-prompt-section>
    brief: Mathematical notation for agent instruction
    description: |
      LaTeX mathematical notation for instructing agents using formal mathematics including equations,
      set theory, summations, integrals, and function definitions with logical operators.

      Two primary uses:
      - **Behavioral instruction**: Define scoring functions, ranking algorithms, or decision rules mathematically
      - **State description**: Formally describe quantities, relationships, or system metrics
    labels:
      - math
      - formal
      - instruction
      - block
    require:
      - syntax.omission
      - syntax.qualifier
    examples:
      - name: latex-behavioral-instruction
        brief: Math defining scoring behavior
        description: Uses LaTeX to instruct the LLM on how to calculate and rank results.
        priority: 0
        purpose: Shows symbolic-latex as behavioral instruction for scoring/ranking
        labels:
          - '<npl-prompt-section type="symbolic-latex">'
          - "\\sum"
          - "behavioral"
        thread:
          - role: system
            message: |
              Rank search results using this relevance scoring function:
              <npl-prompt-section type="symbolic-latex">
              \text{Score}(d, q) = \alpha \cdot \text{TF-IDF}(d, q) + \beta \cdot \text{Freshness}(d) + \gamma \cdot \text{Authority}(d)

              \text{where: }
              \alpha = 0.5, \beta = 0.3, \gamma = 0.2

              \text{TF-IDF}(d, q) = \sum_{t \in q} \text{tf}(t, d) \cdot \log\frac{N}{\text{df}(t)}

              \text{Freshness}(d) = e^{-\lambda \cdot \text{age\_days}(d)}, \lambda = 0.01

              \text{Authority}(d) = \frac{\text{citations}(d)}{\max(\text{citations})}
              </npl-prompt-section>
              Return results in descending order of Score.
          - role: user
            message: |
              Query: "machine learning"
              Documents:
              - A: TF-IDF=0.8, age=30 days, citations=50/100
              - B: TF-IDF=0.6, age=5 days, citations=80/100
              - C: TF-IDF=0.9, age=365 days, citations=95/100
          - role: assistant
            message: |
              Calculating scores:

              **Document A**:
              - Freshness = e^(-0.01 √ó 30) = 0.74
              - Score = 0.5(0.8) + 0.3(0.74) + 0.2(0.5) = 0.40 + 0.22 + 0.10 = **0.72**

              **Document B**:
              - Freshness = e^(-0.01 √ó 5) = 0.95
              - Score = 0.5(0.6) + 0.3(0.95) + 0.2(0.8) = 0.30 + 0.29 + 0.16 = **0.75**

              **Document C**:
              - Freshness = e^(-0.01 √ó 365) = 0.026
              - Score = 0.5(0.9) + 0.3(0.026) + 0.2(0.95) = 0.45 + 0.01 + 0.19 = **0.65**

              **Ranked Results**: B (0.75) > A (0.72) > C (0.65)
      - name: latex-state-description
        brief: Math describing system metrics
        description: Uses LaTeX to formally describe the current state of system metrics.
        priority: 0
        purpose: Shows symbolic-latex as state description for metrics modeling
        labels:
          - '<npl-prompt-section type="symbolic-latex">'
          - "\\frac"
          - "state"
        thread:
          - role: system
            message: |
              Current system health metrics:
              <npl-prompt-section type="symbolic-latex">
              \text{System Health} = \begin{cases}
                \text{Healthy} & \text{if } H \geq 0.8 \\
                \text{Degraded} & \text{if } 0.5 \leq H < 0.8 \\
                \text{Critical} & \text{if } H < 0.5
              \end{cases}

              H = w_1 \cdot A + w_2 \cdot L + w_3 \cdot E

              \text{where: }
              A = \text{Availability} = \frac{\text{uptime}}{\text{total\_time}} = 0.99
              L = \text{Latency Score} = 1 - \frac{\text{p99\_ms}}{1000} = 1 - \frac{250}{1000} = 0.75
              E = \text{Error Rate Score} = 1 - \text{error\_rate} = 1 - 0.02 = 0.98

              w_1 = 0.4, w_2 = 0.35, w_3 = 0.25
              </npl-prompt-section>
              What is the current system status?
          - role: assistant
            message: |
              Calculating system health:

              **Component Scores**:
              - Availability (A) = 0.99
              - Latency Score (L) = 0.75
              - Error Rate Score (E) = 0.98

              **Health Score**:
              H = 0.4(0.99) + 0.35(0.75) + 0.25(0.98)
              H = 0.396 + 0.263 + 0.245 = **0.904**

              **Status**: Healthy (H = 0.904 ‚â• 0.8)

              The system is operating normally. Latency (p99 = 250ms) is the weakest metric but still within acceptable bounds.
      - name: latex-with-calculation
        brief: Math expression evaluation
        description: Shows symbolic-latex expression being computed.
        priority: 1
        purpose: Demonstrates symbolic-latex guiding calculation
        labels:
          - '<npl-prompt-section type="symbolic-latex">'
          - "\\sum"
          - "\\frac"
        thread:
          - role: system
            message: |
              Use this formula:
              <npl-prompt-section type="symbolic-latex">
              \text{Average} = \frac{1}{n} \sum_{i=1}^{n} x_i
              </npl-prompt-section>
          - role: user
            message: Calculate the average for x = [4, 8, 6, 10, 2]
          - role: assistant
            message: |
              Given: x = [4, 8, 6, 10, 2], n = 5

              Sum = 4 + 8 + 6 + 10 + 2 = 30
              Average = (1/5) √ó 30 = 6

              **Result**: Average = 6
      - name: complex-latex
        brief: Piecewise grading function
        description: Uses piecewise functions to instruct classification behavior.
        priority: 2
        purpose: Demonstrates advanced symbolic-latex specifications for behavior
        labels:
          - '<npl-prompt-section type="symbolic-latex">'
          - "\\begin{cases}"
          - "\\{ x \\in ... \\}"
          - "behavioral"
        thread:
          - role: system
            message: |
              Grade student scores using this function:
              <npl-prompt-section type="symbolic-latex">
              \text{grade}(s) = \begin{cases}
                A & \text{if } s \geq 90 \\
                B & \text{if } 80 \leq s < 90 \\
                C & \text{if } 70 \leq s < 80 \\
                F & \text{otherwise}
              \end{cases}

              \text{Passing} = \{ s \in \text{Scores} : \text{grade}(s) \neq F \}
              </npl-prompt-section>
          - role: user
            message: "Grade these scores: [95, 82, 67, 78, 91]"
          - role: assistant
            message: |
              Evaluating each score:
              - 95: s ‚â• 90 ‚Üí **A**
              - 82: 80 ‚â§ s < 90 ‚Üí **B**
              - 67: s < 70 ‚Üí **F**
              - 78: 70 ‚â§ s < 80 ‚Üí **C**
              - 91: s ‚â• 90 ‚Üí **A**

              **Passing** = {95, 82, 78, 91}
              **Passing count**: 4 out of 5
