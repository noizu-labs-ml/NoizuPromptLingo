#!/usr/bin/env bash
# -----------------------------------------------------------------------------
# git-tree
#
# Description:
#   Displays a tree of files under a given target folder in a Git repository,
#   respecting .gitignore. Uses `git ls-files` to determine visible files and
#   `tree --fromfile` to render the directory tree (with fallback if tree
#   is not installed).
#
# Usage:
#   ./git-tree [target-folder]
#
# Examples:
#   ./git-tree
#   ./git-tree deployments/impact-simulation
#
# Requirements:
#   - Must be run inside a Git repository
#   - `tree` command optional (fallback provided)
# -----------------------------------------------------------------------------

set -euo pipefail

TARGET="${1:-.}"

# Resolve absolute path and change to target directory first
# This ensures we find the correct git repo for the target path
if [[ -d "$TARGET" ]]; then
  TARGET_DIR="$(cd "$TARGET" && pwd)"
  TARGET_REL="."
elif [[ -f "$TARGET" ]]; then
  TARGET_DIR="$(cd "$(dirname "$TARGET")" && pwd)"
  TARGET_REL="$(basename "$TARGET")"
else
  # Path doesn't exist yet - try parent directory
  TARGET_DIR="$(cd "$(dirname "$TARGET")" 2>/dev/null && pwd)" || TARGET_DIR="$(pwd)"
  TARGET_REL="$(basename "$TARGET")"
fi

cd "$TARGET_DIR"

git -c core.quotepath=false rev-parse --is-inside-work-tree >/dev/null 2>&1 || {
  echo "Error: not inside a git repository." >&2
  exit 1
}

ROOT="$(git rev-parse --show-toplevel)"

# Calculate relative path from git root to target
TARGET_FROM_ROOT="${TARGET_DIR#$ROOT/}"
if [[ "$TARGET_FROM_ROOT" == "$TARGET_DIR" ]]; then
  # Target dir IS the root
  TARGET_FROM_ROOT="."
fi
if [[ "$TARGET_REL" != "." ]]; then
  if [[ "$TARGET_FROM_ROOT" == "." ]]; then
    TARGET_FROM_ROOT="$TARGET_REL"
  else
    TARGET_FROM_ROOT="$TARGET_FROM_ROOT/$TARGET_REL"
  fi
fi

cd "$ROOT"

# Fallback tree renderer when tree command not available
render_tree_fallback() {
  awk -F/ '
  {
    depth = NF - 1
    for (i = 1; i < NF; i++) {
      prefix = ""
      for (j = 1; j < i; j++) prefix = prefix "│   "
      dir = $i
      key = ""
      for (k = 1; k <= i; k++) key = key "/" $k
      if (!(key in seen)) {
        seen[key] = 1
        print prefix "├── " dir
      }
    }
    prefix = ""
    for (j = 1; j < NF; j++) prefix = prefix "│   "
    print prefix "├── " $NF
  }
  ' | sed 's/│   ├── /├── /; s/│   │/│   │/g'
}

FILES=$(git -c core.quotepath=false ls-files --cached --others --exclude-standard -- "$TARGET_FROM_ROOT")

if command -v tree &>/dev/null; then
  echo "$FILES" | tree --fromfile
else
  echo "."
  echo "$FILES" | sort | render_tree_fallback
fi

