#!/usr/bin/env bash
# -----------------------------------------------------------------------------
# dump_files.sh (Unicode-safe)
#
# Description:
#   Dumps the contents of files under a given target folder in a Git repository,
#   respecting .gitignore. Each file is preceded by a formatted header showing
#   its path and a separator. Optionally filter which files to include using
#   one or more shell globs (e.g., "*.md", "src/*.ts").
#
# Usage:
#   ./dump_files.sh <target-folder> [--glob GLOB ...]
#
# Notes:
#   - Respects .gitignore via `git ls-files --cached --others --exclude-standard`
#   - Matches ANY of the provided -g/--glob patterns (repo-relative paths).
#   - Fully Unicode-safe: UTF-8 locale, Git non-ASCII quoting disabled,
#     NUL-delimited file lists, safe printf, and `cat -- "$f"`.
# -----------------------------------------------------------------------------

set -euo pipefail

# --- Unicode/UTF-8 safety ---
export LC_ALL="${LC_ALL:-en_US.UTF-8}"
export LANG="${LANG:-en_US.UTF-8}"
# If your system lacks en_US.UTF-8, change to a UTF-8 locale that exists (e.g. C.UTF-8).
# ----------------------------

print_help() {
  sed -n '2,40p' "$0" | sed 's/^# \{0,1\}//'
}

if [[ "${1:-}" == "-h" || "${1:-}" == "--help" ]]; then
  print_help
  exit 0
fi

if [[ $# -lt 1 ]]; then
  printf 'Usage: %s <target-folder> [--glob GLOB ...]\n' "$0" >&2
  exit 1
fi

TARGET=""
declare -a GLOBS=()

# --- Parse args ---
TARGET="$1"; shift || true
while [[ $# -gt 0 ]]; do
  case "$1" in
    -g|--glob)
      shift || true
      [[ $# -gt 0 ]] || { printf 'Error: --glob requires a pattern\n' >&2; exit 1; }
      GLOBS+=("$1")
      ;;
    -h|--help)
      print_help; exit 0
      ;;
    *)
      printf 'Unknown argument: %s\n' "$1" >&2
      printf 'Usage: %s <target-folder> [--glob GLOB ...]\n' "$0" >&2
      exit 1
      ;;
  esac
  shift || true
done

# Ensure we're in a git repo and use repo root for stable relative paths
if ! git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
  printf 'Error: not inside a git repository.\n' >&2
  exit 1
fi
ROOT="$(git rev-parse --show-toplevel)"
cd "$ROOT"

# Function: returns 0 if $1 matches any glob in GLOBS (or if no globs specified)
matches_globs() {
  local path="$1"
  # If no globs provided, everything matches
  if [[ ${#GLOBS[@]} -eq 0 ]]; then
    return 0
  fi
  local g
  for g in "${GLOBS[@]}"; do
    # [[ string == pattern ]] does shell-style glob matching (UTF-8 aware under our locale)
    if [[ "$path" == $g ]]; then
      return 0
    fi
  done
  return 1
}

# Use NUL-delimited listing to be safe with any characters in filenames
# Also disable Git's C-style quoting for non-ASCII names.
git -c core.quotepath=false ls-files -z --cached --others --exclude-standard -- "$TARGET" \
  | while IFS= read -r -d '' f; do
      if matches_globs "$f"; then
        printf '\n# %s\n---\n' "%s" "$f"
        # Use -- to stop option parsing in case filename starts with '-'
        if ! cat -- "$f"; then
          printf '<< Failed to read: %s >>\n' "$f" >&2
        fi
        printf '\n* * *\n'
      fi
    done

