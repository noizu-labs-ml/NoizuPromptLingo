#!/usr/bin/env bash
# -----------------------------------------------------------------------------
# dump_files.sh
#
# Description:
#   Dumps the contents of files under a given target folder in a Git repository,
#   respecting .gitignore. Each file is preceded by a formatted header showing
#   its path and a separator. Optionally filter which files to include using
#   one or more shell globs (e.g., "*.md", "src/*.ts").
#
# Usage:
#   ./dump_files.sh <target-folder> [--glob GLOB ...]
#
# Examples:
#   # Dump everything under src/
#   ./dump_files.sh src/
#
#   # Only Markdown files anywhere under docs/
#   ./dump_files.sh docs/ -g "*.md"
#
#   # Multiple patterns (Markdown + TS)
#   ./dump_files.sh . -g "*.md" -g "src/*.ts"
#
# Notes:
#   - Respects .gitignore via `git ls-files --cached --others --exclude-standard`
#   - You can pass multiple -g/--glob options. A file matches if it matches ANY.
#   - Globs are matched against repo-relative paths (e.g., "src/utils/a.ts").
# -----------------------------------------------------------------------------

set -euo pipefail

print_help() {
  sed -n '2,40p' "$0" | sed 's/^# \{0,1\}//'
}

if [[ "${1:-}" == "-h" || "${1:-}" == "--help" ]]; then
  print_help
  exit 0
fi

if [[ $# -lt 1 ]]; then
  echo "Usage: $0 <target-folder> [--glob GLOB ...]" >&2
  exit 1
fi

TARGET=""
GLOBS=()

# --- Parse args ---
TARGET="$1"; shift || true
while [[ $# -gt 0 ]]; do
  case "$1" in
    -g|--glob)
      shift
      [[ $# -gt 0 ]] || { echo "Error: --glob requires a pattern" >&2; exit 1; }
      GLOBS+=("$1")
      ;;
    -h|--help)
      print_help; exit 0
      ;;
    *)
      echo "Unknown argument: $1" >&2
      echo "Usage: $0 <target-folder> [--glob GLOB ...]" >&2
      exit 1
      ;;
  esac
  shift || true
done

# Ensure we're in a git repo and use repo root for stable relative paths
git rev-parse --is-inside-work-tree >/dev/null 2>&1 || {
  echo "Error: not inside a git repository." >&2
  exit 1
}
ROOT="$(git rev-parse --show-toplevel)"
cd "$ROOT"

# Function: returns 0 if $1 matches any glob in GLOBS (or if no globs specified)
matches_globs() {
  local path="$1"
  # If no globs provided, everything matches
  if [[ ${#GLOBS[@]} -eq 0 ]]; then
    return 0
  fi
  local g
  for g in "${GLOBS[@]}"; do
    # Use [[ string == pattern ]] for shell-style glob matching
    if [[ "$path" == $g ]]; then
      return 0
    fi
  done
  return 1
}

# List tracked + untracked but not ignored files, then dump with headers
git ls-files --cached --others --exclude-standard -- "$TARGET" \
  | while read -r f; do
      if matches_globs "$f"; then
        echo -e "\n# $f\n---"
        cat "$f"
        echo -e "\n* * *"
      fi
    done
